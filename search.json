[{"url":"/2018/03/31/java中Integer缓存问题/","content":"先来看一道题\n<pre>\n\t// 程序填空,交换a和b的值,\n\tpublic static void main(String[] args) {\n\t\tint a = 10;\n\t\tint b = 20;\n\t\tswap(a, b);\n\t\tSystem.out.println((Integer) a);//20\n\t\tSystem.out.println((Integer) b);//10\n\t}\n\t\n\tprivate static void swap(int a, int b) {\n\t\t// TODO\n\t}\n</pre>  \n\n我们都知道参数类型为int时,实际上传入的值,而不是地址.所以在swap方法中直接去交换a和b的值是行不通的.那究竟用什么方法呢?\n答案是:反射\n<pre>\n\tprivate static void swap(int a, int b) {\n\t\ttry {\n\t\t\t// 获取Integer的内部类IntegerCache字节码对象.\n\t\t\tClass<?> clazz = Class.forName(\"java.lang.Integer$IntegerCache\");\n\t\t\t// 获取IntegerCache名为cache的字段.\n\t\t\tField field = clazz.getDeclaredField(\"cache\");\n\t\t\t// 设置该字段的访问权限\n\t\t\tfield.setAccessible(true);\n\t\t\t// 获取field在IntegerCache实际的值\n\t\t\tInteger[] cache = (Integer[]) field.get(clazz);\n\t\t\t// 修改第129个位置的值(原本为1)为2\n\t\t\tcache[129] = new Integer(2);// 此处必须使用new Integer(i)的方式来修改.\n\t\t\t// 修改第130个位置的值(原本为2)为1\n\t\t\tcache[130] = new Integer(1);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n</pre>\n在[-128,127]范围内的值我们可以通过上面的方法直接去修改IntegerCache的值.但最后打印的时候必须要强转成Integer类型,否则打印出来是原始值.\n超过上述范围时,我们可以通过下面代码来修改\n<pre>\n\t\n</pre>\n\nInteger的缓存机制.\n我们经常会看到一道面试题是这样的.\n<pre>\n\tInteger a = 10;\n\tint b = 10;\n\tInteger c = Integer.valueOf(10);\n\tInteger d = new Integer(10);\n\t\n\t以下输出结果为false的是：\n\t\n\tA.   System.out.println(a == b); // true\n\tB.   System.out.println(a == c); // true\n\tC.   System.out.println(c == d); // false\n\tD.   System.out.println(b == d); // false\n</pre>\n我们先看一下\n<pre>\n\tint a = 5;\n\tInteger b = 5;\n\t//这两句话都做了什么,我们反编译一下class文件.\n\tint a = 5;\n\tInteger b = Integer.valueOf(5);\n</pre>\n\n\n<pre>\n\t// Returns an {@code Integer} instance representing the specified\n    // {@code int} value.  If a new {@code Integer} instance is not\n    // required, this method should generally be used in preference to\n    // the constructor {@link #Integer(int)}, as this method is likely\n    // to yield significantly better space and time performance by\n    // caching frequently requested values.\n    // This method will always cache values in the range -128 to 127,\n    // inclusive, and may cache other values outside of this range.\n \tpublic static Integer valueOf(int i) {\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n</pre>\n如果新的实例不是必须的话,那么创建int或Integer值在[-128,127]范围内时,会直接调用IntegerCache里面的对应的缓存值.那么问题来了,为什么要这样做呢.注释中已经有了解答.因为这个范围内的值访问的会比较频繁.设置缓存会\n<pre>\n      // Cache to support the object identity semantics of autoboxing for values between\n      // -128 and 127 (inclusive) as required by JLS.\n      // The cache is initialized on first usage.  The size of the cache\n      // may be controlled by the {@code -XX:AutoBoxCacheMax=<size>} option.\n      // During VM initialization, java.lang.Integer.IntegerCache.high property\n      // may be set and saved in the private system properties in the\n      // sun.misc.VM class.\n\t  private static class IntegerCache {\n        static final int low = -128;\n        static final int high;\n        static final Integer cache[];\n        static {\n            // high value may be configured by property\n            int h = 127;\n            String integerCacheHighPropValue =\n                sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue != null) {\n                try {\n                    int i = parseInt(integerCacheHighPropValue);\n                    i = Math.max(i, 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high = h;\n            cache = new Integer[(high - low) + 1];\n            int j = low;\n            for(int k = 0; k < cache.length; k++)\n                cache[k] = new Integer(j++);\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high >= 127;\n        }\n        private IntegerCache() {}\n    }\n</pre>\n通过注释可以看到: 对[-128,127]这个范围内值进行缓存.在第一使用缓存时,这个缓存会被初始化,缓存的大小可以通过option中的{@code -XX:AutoBoxCacheMax=<size>}来设置.\n"},{"url":"/2018/03/31/JavaScript闭包/","content":"#JavaScript的闭包(Closure)\n\n----------\n\n>本文权当是笔记,后期飞升之后,再回来补自己的理解与体会.并将自己在实际中用到的经验分享出来.\n\n##闭包:\n　有权访问另一个函数作用域中的变量的函数.创建闭包的常见方式就是在一个函数内部创建另一个函数\n<pre>\n\tfunction createComparisonFunction(propertyName){\n\t\treturn function(object1, object2){\n\t\t\tvar value1=object1[propertyName];\n\t\t\tvar value2=object2[propertyName];\n\t\t\tif (value1 < value2){\n\t\t\t\treturn -1;\t\t\n\t\t\t}else if(value1 > value2){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treutn 0;\t\n\t\t\t}\t\n\t\t};\n\t}\n</pre>\n\n##作用域链：\n　当某个函数第一次被调用时，会创建一个执行环境（ｅｘｅｃｕｔｉｏｎ　ｃｏｎｔｅｘｔ）及相应的作用域链，并把作用域链赋值给一个特殊的内部属性（［［Ｓｃｏｐｅ］］）．然后使用ｔｈｉｓ．ａｒｇｕｍｅｎｔｓ和其他命名参数的值来初始化函数的活动对象（ａｃｔｉｖａｔｉｏｎ　ｏｂｊｅｃｔ）．但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位．．．．直至作为作用域链终点的全局执行环境\n<pre>\n\tfunction compare(value1,value2){\n\t\tif(value1 < value2){\n\t\t\treturn -1;\n\t\t}else if(value1 > value2){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvar result = compare(5,10);\n</pre>\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当第一次调用compare()时,会创建一个包含this.arguments,value1和value2的活动对象.全局执行环境的变量对象(包含this.result.compare)在compare()执行环境的作用域链处于第二位\n如下图:\n\t![](https://i.imgur.com/jkpmWLK.png)\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后台的每个执行环境都有一个表示变量的对象--变量对象(variable object).全局环境的变量对象始终存在,而像compare()函数这样的局部环境的变量对象,则只在函数执行的过程中存在.在创建compare()函数时,会创建一个预先包含全局变量对象的作用域链,这个作用域链被保存在内部的[[Scope]]属性中.\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当调用compare()函数时,会为函数创建一个执行环境,然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链.此后,又有一个活动对象"}]